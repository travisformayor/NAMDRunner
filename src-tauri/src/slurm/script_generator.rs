use crate::types::*;
use anyhow::{anyhow, Result};

/// SLURM script generator for NAMD molecular dynamics jobs
pub struct SlurmScriptGenerator;

impl SlurmScriptGenerator {
    /// Generate a complete SLURM batch script for a NAMD job
    pub fn generate_namd_script(job_info: &JobInfo, scratch_dir: &str) -> Result<String> {
        // Validate inputs before script generation
        Self::validate_job_info(job_info)?;

        // Extract configuration details
        let job_name = Self::sanitize_slurm_job_name(&job_info.job_name);
        let slurm_config = &job_info.slurm_config;

        // Parse and validate memory value using centralized parser
        let memory_gb = slurm_config.parse_memory_gb()
            .map_err(|e| anyhow!("Invalid memory specification: {}", e))?;
        let memory_with_unit = format!("{}GB", memory_gb);

        // Use provided scratch directory as working directory
        let working_dir = scratch_dir;

        // Build script from modular sections
        let sections = [
            Self::build_shebang(),
            Self::build_slurm_directives(&job_name, slurm_config, &memory_with_unit)?,
            Self::build_job_metadata(job_info),
            Self::build_environment_setup(),
            Self::build_module_loads(),
            Self::build_working_directory(working_dir),
            Self::build_namd_execution(slurm_config.cores),
        ];

        Ok(sections.join("\n"))
    }

    // DELETED: generate_namd_config() - NAMD config is now rendered from templates
    // See crate::templates::render_template() for template-based config generation

    // ===== SLURM Script Section Builders =====

    fn build_shebang() -> String {
        "#!/bin/bash".to_string()
    }

    fn build_slurm_directives(job_name: &str, config: &SlurmConfig, memory: &str) -> Result<String> {
        let partition = config.partition.as_deref()
            .unwrap_or("amilan");

        let qos = config.qos.as_deref()
            .unwrap_or("normal");

        Ok(format!(
            "#SBATCH --job-name={}\n\
             #SBATCH --output={}_%j.out\n\
             #SBATCH --error={}_%j.err\n\
             #SBATCH --partition={}\n\
             #SBATCH --nodes=1\n\
             #SBATCH --ntasks={}\n\
             #SBATCH --time={}\n\
             #SBATCH --mem={}\n\
             #SBATCH --qos={}\n\
             #SBATCH --constraint=ib",
            job_name, job_name, job_name, partition,
            config.cores, config.walltime, memory, qos
        ))
    }

    fn build_job_metadata(job_info: &JobInfo) -> String {
        format!(
            "\n# Generated by NAMDRunner on {}\n\
             # Job ID: {}\n\
             # Job Name: {}",
            chrono::Utc::now().to_rfc3339(),
            job_info.job_id,
            job_info.job_name
        )
    }

    fn build_environment_setup() -> String {
        "\n# Initialize module environment\n\
         source /etc/profile\n\
         export SLURM_EXPORT_ENV=ALL  # Required for OpenMPI".to_string()
    }

    fn build_module_loads() -> String {
        "\n# Load required modules for NAMD execution\n\
         module purge\n\
         module load gcc/14.2.0\n\
         module load openmpi/5.0.6\n\
         module load namd/3.0.1_cpu".to_string()
    }

    fn build_working_directory(dir: &str) -> String {
        format!("\n# Change to working directory\ncd {}", dir)
    }

    fn build_namd_execution(_cores: u32) -> String {
        "\n# Execute NAMD with MPI (OpenMPI handles CPU affinity automatically)\n\
             mpirun -np $SLURM_NTASKS namd3 config.namd > namd_output.log".to_string()
    }

    // DELETED: All NAMD config section builders - replaced by template system
    // NAMD config is now generated by rendering templates with variables

    // ===== Helper Functions =====

    fn sanitize_slurm_job_name(name: &str) -> String {
        name.chars()
            .map(|c| if c.is_alphanumeric() || c == '-' { c } else { '_' })
            .collect()
    }

    // DELETED: extract_input_files() - no longer needed with template system
    // Files are now managed through template variables

    fn validate_job_info(job_info: &JobInfo) -> Result<()> {
        // Validate job name
        if job_info.job_name.trim().is_empty() {
            return Err(anyhow!("Job name cannot be empty"));
        }

        // Validate SLURM configuration
        let slurm_config = &job_info.slurm_config;
        if slurm_config.cores < 1 {
            return Err(anyhow!("Core count must be at least 1"));
        }

        // Phase 6 constraint: Single-node only (nodes=1 always in script)
        if slurm_config.cores > 64 {
            return Err(anyhow!("Core count cannot exceed 64 (single node limit for amilan partition)"));
        }

        if slurm_config.walltime.is_empty() {
            return Err(anyhow!("Walltime cannot be empty"));
        }

        if slurm_config.memory.is_empty() {
            return Err(anyhow!("Memory specification cannot be empty"));
        }

        // Scratch directory is now passed as parameter, no need to validate

        Ok(())
    }

    // DELETED: validate_namd_config() - validation now handled by template system
    // See crate::templates::validation for template-based validation
}

// DELETED: All tests - will be rewritten for template system in later steps
// Tests will validate SLURM script generation only (NAMD config is handled by templates)