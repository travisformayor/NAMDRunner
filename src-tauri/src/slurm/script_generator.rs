use crate::types::*;
use anyhow::{anyhow, Result};

/// SLURM script generator for NAMD molecular dynamics jobs
pub struct SlurmScriptGenerator;

impl SlurmScriptGenerator {
    /// Generate a complete SLURM batch script for a NAMD job
    pub fn generate_namd_script(job_info: &JobInfo, scratch_dir: &str) -> Result<String> {
        // Validate inputs before script generation
        Self::validate_job_info(job_info)?;

        // Extract configuration details
        let job_name = Self::sanitize_slurm_job_name(&job_info.job_name);
        let slurm_config = &job_info.slurm_config;

        // Parse and validate memory value using centralized parser
        let memory_gb = slurm_config.parse_memory_gb()
            .map_err(|e| anyhow!("Invalid memory specification: {}", e))?;
        let memory_with_unit = format!("{}GB", memory_gb);

        // Use provided scratch directory as working directory
        let working_dir = scratch_dir;

        // Build script from modular sections
        let sections = [
            Self::build_shebang(),
            Self::build_slurm_directives(&job_name, slurm_config, &memory_with_unit)?,
            Self::build_job_metadata(job_info),
            Self::build_environment_setup(),
            Self::build_module_loads(),
            Self::build_working_directory(working_dir),
            Self::build_namd_execution(slurm_config.cores),
        ];

        Ok(sections.join("\n"))
    }

    /// Generate a preview SLURM script with minimal parameters
    /// Used for UI preview without needing complete JobInfo
    pub fn preview_script(job_name: String, slurm_config: SlurmConfig) -> Result<String> {
        // Validate configuration
        Self::validate_slurm_config(&slurm_config)?;

        // Sanitize job name for SLURM
        let safe_job_name = Self::sanitize_slurm_job_name(&job_name);

        // Parse memory
        let memory_gb = slurm_config.parse_memory_gb()
            .map_err(|e| anyhow!("Invalid memory specification: {}", e))?;
        let memory_with_unit = format!("{}GB", memory_gb);

        // Use example directories for preview
        let preview_scratch_dir = "/scratch/alpine/user/namdrunner_jobs/preview_job";

        // Build script sections (without job metadata since this is preview)
        let sections = [
            Self::build_shebang(),
            Self::build_slurm_directives(&safe_job_name, &slurm_config, &memory_with_unit)?,
            Self::build_preview_comment(),
            Self::build_environment_setup(),
            Self::build_module_loads(),
            Self::build_working_directory(preview_scratch_dir),
            Self::build_namd_execution(slurm_config.cores),
        ];

        Ok(sections.join("\n"))
    }

    // See crate::templates::render_template() for template-based config generation

    // ===== SLURM Script Section Builders =====

    fn build_shebang() -> String {
        "#!/bin/bash".to_string()
    }

    fn build_slurm_directives(job_name: &str, config: &SlurmConfig, memory: &str) -> Result<String> {
        Ok(format!(
            "#SBATCH --job-name={}\n\
             #SBATCH --output={}_%j.out\n\
             #SBATCH --error={}_%j.err\n\
             #SBATCH --partition={}\n\
             #SBATCH --nodes=1\n\
             #SBATCH --ntasks={}\n\
             #SBATCH --time={}\n\
             #SBATCH --mem={}\n\
             #SBATCH --qos={}\n\
             #SBATCH --constraint=ib",
            job_name, job_name, job_name, config.partition,
            config.cores, config.walltime, memory, config.qos
        ))
    }

    fn build_job_metadata(job_info: &JobInfo) -> String {
        format!(
            "\n# Generated by NAMDRunner on {}\n\
             # Job ID: {}\n\
             # Job Name: {}",
            chrono::Utc::now().to_rfc3339(),
            job_info.job_id,
            job_info.job_name
        )
    }

    fn build_preview_comment() -> String {
        format!(
            "\n# PREVIEW - Generated by NAMDRunner on {}\n\
             # This is a preview of the SLURM batch script",
            chrono::Utc::now().to_rfc3339()
        )
    }

    fn build_environment_setup() -> String {
        "\n# Initialize module environment\n\
         source /etc/profile\n\
         export SLURM_EXPORT_ENV=ALL  # Required for OpenMPI".to_string()
    }

    fn build_module_loads() -> String {
        "\n# Load required modules for NAMD execution\n\
         module purge\n\
         module load gcc/14.2.0\n\
         module load openmpi/5.0.6\n\
         module load namd/3.0.1_cpu".to_string()
    }

    fn build_working_directory(dir: &str) -> String {
        format!("\n# Change to working directory\ncd {}", dir)
    }

    fn build_namd_execution(_cores: u32) -> String {
        "\n# Execute NAMD with MPI (OpenMPI handles CPU affinity automatically)\n\
             mpirun -np $SLURM_NTASKS namd3 config.namd > namd_output.log".to_string()
    }

    // ===== Helper Functions =====

    fn sanitize_slurm_job_name(name: &str) -> String {
        name.chars()
            .map(|c| if c.is_alphanumeric() || c == '-' { c } else { '_' })
            .collect()
    }

    fn validate_job_info(job_info: &JobInfo) -> Result<()> {
        // Validate job name
        if job_info.job_name.trim().is_empty() {
            return Err(anyhow!("Job name cannot be empty"));
        }

        Self::validate_slurm_config(&job_info.slurm_config)
    }

    fn validate_slurm_config(slurm_config: &SlurmConfig) -> Result<()> {
        if slurm_config.cores < 1 {
            return Err(anyhow!("Core count must be at least 1"));
        }

        if slurm_config.cores > 64 {
            return Err(anyhow!("Core count cannot exceed 64 (single node limit for amilan partition)"));
        }

        if slurm_config.walltime.is_empty() {
            return Err(anyhow!("Walltime cannot be empty"));
        }

        if slurm_config.memory.is_empty() {
            return Err(anyhow!("Memory specification cannot be empty"));
        }

        Ok(())
    }

    // See crate::templates::validation for template-based validation
}

// Tests will validate SLURM script generation only (NAMD config is handled by templates)