use crate::types::*;
use crate::slurm::namd_constants::*;
use anyhow::{anyhow, Result};

/// SLURM script generator for NAMD molecular dynamics jobs
pub struct SlurmScriptGenerator;

impl SlurmScriptGenerator {
    /// Generate a complete SLURM batch script for a NAMD job
    pub fn generate_namd_script(job_info: &JobInfo) -> Result<String> {
        // Validate inputs before script generation
        Self::validate_job_info(job_info)?;

        // Extract configuration details
        let job_name = Self::sanitize_slurm_job_name(&job_info.job_name);
        let slurm_config = &job_info.slurm_config;

        // Ensure memory has unit suffix (GB or MB) - critical for correct allocation
        let memory_with_unit = Self::ensure_memory_unit(&slurm_config.memory);

        // Get scratch directory for working directory
        let working_dir = job_info.scratch_dir
            .as_ref()
            .ok_or_else(|| anyhow!("Job scratch directory not configured"))?;

        // Build script from modular sections
        let mut sections = Vec::new();

        sections.push(Self::build_shebang());
        sections.push(Self::build_slurm_directives(&job_name, slurm_config, &memory_with_unit)?);
        sections.push(Self::build_job_metadata(job_info));
        sections.push(Self::build_environment_setup());
        sections.push(Self::build_module_loads());
        sections.push(Self::build_working_directory(working_dir));
        sections.push(Self::build_namd_execution(slurm_config.cores));

        Ok(sections.join("\n"))
    }

    /// Generate NAMD configuration file content
    pub fn generate_namd_config(job_info: &JobInfo) -> Result<String> {
        let namd_config = &job_info.namd_config;

        // Validate required conditions
        Self::validate_namd_config(namd_config)?;

        // Extract files by type
        let (psf_file, pdb_file, param_files, exb_files) = Self::extract_input_files(job_info)?;

        // Build configuration from modular sections
        let mut sections = Vec::new();

        sections.push(Self::build_config_header(job_info));
        sections.push(Self::build_structure_section(&psf_file.name, &pdb_file.name));
        sections.push(Self::build_output_section(&namd_config.outputname));
        sections.push(Self::build_temperature_section(namd_config.temperature));

        // Add cell basis vectors if PME is enabled
        if namd_config.pme_enabled {
            sections.push(Self::build_cell_basis_section(namd_config)?);
        }

        sections.push(Self::build_parameters_section(&param_files));
        sections.push(Self::build_force_field_section());
        sections.push(Self::build_integrator_section(namd_config.timestep));

        // Add PME section if enabled
        if namd_config.pme_enabled {
            sections.push(Self::build_pme_section());
        }

        sections.push(Self::build_temperature_control_section(namd_config));

        // Add pressure control if NPT is enabled
        if namd_config.npt_enabled {
            sections.push(Self::build_pressure_control_section(namd_config.temperature));
        }

        sections.push(Self::build_output_frequencies_section(namd_config));
        sections.push(Self::build_wrap_section());

        // Add extrabonds if present
        if !exb_files.is_empty() {
            sections.push(Self::build_extrabonds_section(&exb_files));
        }

        sections.push(Self::build_execution_section(namd_config));

        Ok(sections.join("\n"))
    }

    // ===== SLURM Script Section Builders =====

    fn build_shebang() -> String {
        "#!/bin/bash".to_string()
    }

    fn build_slurm_directives(job_name: &str, config: &SlurmConfig, memory: &str) -> Result<String> {
        let partition = config.partition.as_ref()
            .map(|p| p.as_str())
            .unwrap_or("amilan");

        let qos = config.qos.as_ref()
            .map(|q| q.as_str())
            .unwrap_or("normal");

        Ok(format!(
            "#SBATCH --job-name={}\n\
             #SBATCH --output={}_%j.out\n\
             #SBATCH --error={}_%j.err\n\
             #SBATCH --partition={}\n\
             #SBATCH --nodes=1\n\
             #SBATCH --ntasks={}\n\
             #SBATCH --time={}\n\
             #SBATCH --mem={}\n\
             #SBATCH --qos={}\n\
             #SBATCH --constraint=ib",
            job_name, job_name, job_name, partition,
            config.cores, config.walltime, memory, qos
        ))
    }

    fn build_job_metadata(job_info: &JobInfo) -> String {
        format!(
            "\n# Generated by NAMDRunner on {}\n\
             # Job ID: {}\n\
             # Job Name: {}",
            chrono::Utc::now().to_rfc3339(),
            job_info.job_id,
            job_info.job_name
        )
    }

    fn build_environment_setup() -> String {
        "\n# Initialize module environment\n\
         source /etc/profile\n\
         export SLURM_EXPORT_ENV=ALL  # Required for OpenMPI".to_string()
    }

    fn build_module_loads() -> String {
        "\n# Load required modules for NAMD execution\n\
         module purge\n\
         module load gcc/14.2.0\n\
         module load openmpi/5.0.6\n\
         module load namd/3.0.1_cpu".to_string()
    }

    fn build_working_directory(dir: &str) -> String {
        format!("\n# Change to working directory\ncd {}", dir)
    }

    fn build_namd_execution(cores: u32) -> String {
        format!(
            "\n# Execute NAMD with MPI (OpenMPI handles CPU affinity automatically)\n\
             mpirun -np {} namd3 scripts/config.namd > namd_output.log",
            cores
        )
    }

    // ===== NAMD Config Section Builders =====

    fn build_config_header(job_info: &JobInfo) -> String {
        format!(
            "#############################################################\n\
             ## JOB DESCRIPTION                                         ##\n\
             #############################################################\n\
             # {}\n\
             # Generated by NAMDRunner on {}\n\
             # Job ID: {}",
            job_info.job_name,
            chrono::Utc::now().to_rfc3339(),
            job_info.job_id
        )
    }

    fn build_structure_section(psf_name: &str, pdb_name: &str) -> String {
        format!(
            "\n#############################################################\n\
             ## ADJUSTABLE PARAMETERS                                   ##\n\
             #############################################################\n\n\
             # Input structure and coordinates\n\
             structure          {}\n\
             coordinates        {}",
            crate::ssh::JobDirectoryStructure::input_path(psf_name),
            crate::ssh::JobDirectoryStructure::input_path(pdb_name)
        )
    }

    fn build_output_section(outputname: &str) -> String {
        format!(
            "\n# Output naming\n\
             outputName         {}\n\
             binaryoutput       yes",
            crate::ssh::JobDirectoryStructure::output_path(outputname)
        )
    }

    fn build_temperature_section(temperature: f64) -> String {
        format!(
            "\n# Temperature for this simulation\n\
             set temperature    {}\n\
             temperature        $temperature\n\
             firsttimestep      0",
            temperature
        )
    }

    fn build_cell_basis_section(config: &NAMDConfig) -> Result<String> {
        // Require all three vectors if PME is enabled
        let v1 = config.cell_basis_vector1.as_ref()
            .ok_or_else(|| anyhow!("cellBasisVector1 required when PME is enabled"))?;
        let v2 = config.cell_basis_vector2.as_ref()
            .ok_or_else(|| anyhow!("cellBasisVector2 required when PME is enabled"))?;
        let v3 = config.cell_basis_vector3.as_ref()
            .ok_or_else(|| anyhow!("cellBasisVector3 required when PME is enabled"))?;

        Ok(format!(
            "\n# Periodic boundary conditions\n\
             cellBasisVector1   {:.1}     {:.1}      {:.1}\n\
             cellBasisVector2   {:.1}     {:.1}      {:.1}\n\
             cellBasisVector3   {:.1}     {:.1}      {:.1}",
            v1.x, v1.y, v1.z,
            v2.x, v2.y, v2.z,
            v3.x, v3.y, v3.z
        ))
    }

    fn build_parameters_section(param_files: &[&InputFile]) -> String {
        let mut section = String::from(
            "\n#############################################################\n\
             ## SIMULATION PARAMETERS                                   ##\n\
             #############################################################\n\n\
             # Force field parameters\n\
             paraTypeCharmm     on"
        );

        for file in param_files {
            section.push_str(&format!(
                "\nparameters         {}",
                crate::ssh::JobDirectoryStructure::input_path(&file.name)
            ));
        }

        section
    }

    fn build_force_field_section() -> String {
        format!(
            "\n# Non-bonded force calculations\n\
             exclude            {}\n\
             1-4scaling         {}\n\
             switching          on\n\
             switchdist         {}\n\
             cutoff             {}\n\
             pairlistdist       {}",
            EXCLUDE, SCALING_1_4, SWITCH_DIST, CUTOFF, PAIRLIST_DIST
        )
    }

    fn build_integrator_section(timestep: f64) -> String {
        format!(
            "\n# Integration parameters\n\
             timestep           {}\n\
             rigidBonds         {}\n\
             nonbondedFreq      {}\n\
             fullElectFrequency {}\n\
             stepspercycle      {}",
            timestep, RIGID_BONDS, NONBONDED_FREQ, FULL_ELECT_FREQUENCY, STEPS_PER_CYCLE
        )
    }

    fn build_pme_section() -> String {
        format!(
            "\n# PME (Particle Mesh Ewald) for electrostatics\n\
             PME                yes\n\
             PMEGridSpacing     {}",
            PME_GRID_SPACING
        )
    }

    fn build_temperature_control_section(config: &NAMDConfig) -> String {
        format!(
            "\n# Temperature control (Langevin dynamics)\n\
             langevin           on\n\
             langevinDamping    {}\n\
             langevinTemp       $temperature\n\
             langevinHydrogen   {}",
            config.langevin_damping,
            if LANGEVIN_HYDROGEN { "on" } else { "off" }
        )
    }

    fn build_pressure_control_section(temperature: f64) -> String {
        format!(
            "\n# Pressure control (NPT ensemble)\n\
             langevinPiston        on\n\
             langevinPistonTarget  {}\n\
             langevinPistonPeriod  {}\n\
             langevinPistonDecay   {}\n\
             langevinPistonTemp    {}",
            LANGEVIN_PISTON_TARGET,
            LANGEVIN_PISTON_PERIOD,
            LANGEVIN_PISTON_DECAY,
            temperature
        )
    }

    fn build_output_frequencies_section(config: &NAMDConfig) -> String {
        format!(
            "\n# Output frequencies (in timesteps)\n\
             xstFreq            {}\n\
             outputEnergies     {}\n\
             dcdfreq            {}\n\
             restartfreq        {}\n\
             outputPressure     {}",
            config.xst_freq,
            config.output_energies_freq,
            config.dcd_freq,
            config.restart_freq,
            config.output_pressure_freq
        )
    }

    fn build_wrap_section() -> String {
        format!(
            "\n# Trajectory wrapping\n\
             wrapAll            {}\n\
             wrapWater          {}",
            if WRAP_ALL { "on" } else { "off" },
            if WRAP_WATER { "on" } else { "off" }
        )
    }

    fn build_extrabonds_section(exb_files: &[&InputFile]) -> String {
        let mut section = String::from(
            "\n# Extra bonds (harmonic restraints)\n\
             extraBonds         on"
        );

        for file in exb_files {
            section.push_str(&format!(
                "\nextraBondsFile     {}",
                crate::ssh::JobDirectoryStructure::input_path(&file.name)
            ));
        }

        section
    }

    fn build_execution_section(config: &NAMDConfig) -> String {
        let command = match config.execution_mode {
            ExecutionMode::Minimize => format!("minimize           {}", config.steps),
            ExecutionMode::Run => format!("run                {}", config.steps),
        };

        format!(
            "\n#############################################################\n\
             ## EXECUTION SCRIPT                                        ##\n\
             #############################################################\n\n\
             # {} simulation\n\
             {}",
            match config.execution_mode {
                ExecutionMode::Minimize => "Minimization",
                ExecutionMode::Run => "Production",
            },
            command
        )
    }

    // ===== Helper Functions =====

    fn ensure_memory_unit(memory: &str) -> String {
        if memory.contains("GB") || memory.contains("MB") {
            memory.to_string()
        } else {
            // Assume GB if no unit specified (most common case)
            format!("{}GB", memory)
        }
    }

    fn sanitize_slurm_job_name(name: &str) -> String {
        name.chars()
            .map(|c| if c.is_alphanumeric() || c == '-' { c } else { '_' })
            .collect()
    }

    fn extract_input_files(job_info: &JobInfo) -> Result<(
        &InputFile,  // PSF
        &InputFile,  // PDB
        Vec<&InputFile>,  // PRMs
        Vec<&InputFile>,  // EXBs
    )> {
        // PSF file (required)
        let psf_file = job_info.input_files.iter()
            .find(|f| matches!(f.file_type, Some(NAMDFileType::Psf)))
            .ok_or_else(|| anyhow!("No PSF file found in input files"))?;

        // PDB file (required)
        let pdb_file = job_info.input_files.iter()
            .find(|f| matches!(f.file_type, Some(NAMDFileType::Pdb)))
            .ok_or_else(|| anyhow!("No PDB file found in input files"))?;

        // Parameter files (at least one required)
        let param_files: Vec<_> = job_info.input_files.iter()
            .filter(|f| matches!(f.file_type, Some(NAMDFileType::Prm)))
            .collect();

        if param_files.is_empty() {
            return Err(anyhow!("No parameter files found in input files"));
        }

        // Extrabonds files (optional)
        let exb_files: Vec<_> = job_info.input_files.iter()
            .filter(|f| matches!(f.file_type, Some(NAMDFileType::Exb)))
            .collect();

        Ok((psf_file, pdb_file, param_files, exb_files))
    }

    fn validate_job_info(job_info: &JobInfo) -> Result<()> {
        // Validate job name
        if job_info.job_name.trim().is_empty() {
            return Err(anyhow!("Job name cannot be empty"));
        }

        // Validate SLURM configuration
        let slurm_config = &job_info.slurm_config;
        if slurm_config.cores < 1 {
            return Err(anyhow!("Core count must be at least 1"));
        }

        // Phase 6 constraint: Single-node only (nodes=1 always in script)
        if slurm_config.cores > 64 {
            return Err(anyhow!("Core count cannot exceed 64 (single node limit for amilan partition)"));
        }

        if slurm_config.walltime.is_empty() {
            return Err(anyhow!("Walltime cannot be empty"));
        }

        if slurm_config.memory.is_empty() {
            return Err(anyhow!("Memory specification cannot be empty"));
        }

        // Validate scratch directory is configured
        if job_info.scratch_dir.is_none() {
            return Err(anyhow!("Scratch directory not configured for job"));
        }

        Ok(())
    }

    fn validate_namd_config(config: &NAMDConfig) -> Result<()> {
        // Validate steps
        if config.steps < 1 {
            return Err(anyhow!("Simulation steps must be positive"));
        }

        // Validate temperature
        if config.temperature < 0.0 || config.temperature > 1000.0 {
            return Err(anyhow!("Temperature {} K is outside valid range (0-1000 K)", config.temperature));
        }

        // Validate timestep
        if config.timestep < 0.1 || config.timestep > 4.0 {
            return Err(anyhow!("Timestep {} fs is outside safe range (0.1-4.0 fs)", config.timestep));
        }

        // Validate PME requirements
        if config.pme_enabled {
            if config.cell_basis_vector1.is_none() ||
               config.cell_basis_vector2.is_none() ||
               config.cell_basis_vector3.is_none() {
                return Err(anyhow!("PME requires all three cellBasisVectors to be defined"));
            }
        }

        // Validate output frequencies
        if config.xst_freq == 0 || config.output_energies_freq == 0 ||
           config.dcd_freq == 0 || config.restart_freq == 0 ||
           config.output_pressure_freq == 0 {
            return Err(anyhow!("All output frequencies must be greater than 0"));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_job() -> JobInfo {
        JobInfo {
            job_id: "test_job_001".to_string(),
            job_name: "Test NAMD Job".to_string(),
            namd_config: NAMDConfig {
                outputname: "test_output".to_string(),
                temperature: 300.0,
                timestep: 2.0,
                execution_mode: ExecutionMode::Run,
                steps: 100000,
                cell_basis_vector1: Some(CellBasisVector { x: 124.0, y: 0.0, z: 0.0 }),
                cell_basis_vector2: Some(CellBasisVector { x: 0.0, y: 114.0, z: 0.0 }),
                cell_basis_vector3: Some(CellBasisVector { x: 0.0, y: 0.0, z: 323.0 }),
                pme_enabled: true,
                npt_enabled: true,
                langevin_damping: 5.0,
                xst_freq: 1200,
                output_energies_freq: 1200,
                dcd_freq: 1200,
                restart_freq: 1200,
                output_pressure_freq: 1200,
            },
            slurm_config: SlurmConfig {
                cores: 24,
                memory: "32GB".to_string(),
                walltime: "04:00:00".to_string(),
                partition: Some("amilan".to_string()),
                qos: None,
            },
            input_files: vec![
                InputFile {
                    name: "structure.psf".to_string(),
                    local_path: "/tmp/structure.psf".to_string(),
                    remote_name: Some("structure.psf".to_string()),
                    file_type: Some(NAMDFileType::Psf),
                    size: Some(1024),
                    uploaded_at: Some(chrono::Utc::now().to_rfc3339()),
                },
                InputFile {
                    name: "structure.pdb".to_string(),
                    local_path: "/tmp/structure.pdb".to_string(),
                    remote_name: Some("structure.pdb".to_string()),
                    file_type: Some(NAMDFileType::Pdb),
                    size: Some(2048),
                    uploaded_at: Some(chrono::Utc::now().to_rfc3339()),
                },
                InputFile {
                    name: "par_all36_na.prm".to_string(),
                    local_path: "/tmp/par_all36_na.prm".to_string(),
                    remote_name: Some("par_all36_na.prm".to_string()),
                    file_type: Some(NAMDFileType::Prm),
                    size: Some(512),
                    uploaded_at: Some(chrono::Utc::now().to_rfc3339()),
                },
                InputFile {
                    name: "restraints.exb".to_string(),
                    local_path: "/tmp/restraints.exb".to_string(),
                    remote_name: Some("restraints.exb".to_string()),
                    file_type: Some(NAMDFileType::Exb),
                    size: Some(256),
                    uploaded_at: Some(chrono::Utc::now().to_rfc3339()),
                },
            ],
            output_files: None,
            project_dir: Some("/projects/testuser/namdrunner_jobs/test_job_001".to_string()),
            scratch_dir: Some("/scratch/alpine/testuser/namdrunner_jobs/test_job_001".to_string()),
            status: JobStatus::Created,
            created_at: chrono::Utc::now().to_rfc3339(),
            updated_at: None,
            submitted_at: None,
            completed_at: None,
            slurm_job_id: None,
            error_info: None,
            slurm_stdout: None,
            slurm_stderr: None,
            remote_directory: "/projects/testuser/namdrunner_jobs/test_job_001".to_string(),
        }
    }

    #[test]
    fn test_generate_slurm_script() {
        let job = create_test_job();
        let script = SlurmScriptGenerator::generate_namd_script(&job).unwrap();

        // Verify essential SLURM directives
        assert!(script.contains("#SBATCH --job-name=Test_NAMD_Job"));
        assert!(script.contains("#SBATCH --ntasks=24"));
        assert!(script.contains("#SBATCH --time=04:00:00"));
        assert!(script.contains("#SBATCH --mem=32GB"));
        assert!(script.contains("#SBATCH --partition=amilan"));

        // Verify module loading
        assert!(script.contains("module purge"));
        assert!(script.contains("module load gcc/14.2.0"));
        assert!(script.contains("module load openmpi/5.0.6"));
        assert!(script.contains("module load namd/3.0.1_cpu"));

        // Verify NAMD execution
        assert!(script.contains("mpirun -np 24 namd3"));
        assert!(!script.contains("+setcpuaffinity"));
        assert!(script.contains("scripts/config.namd > namd_output.log"));

        // Verify working directory
        assert!(script.contains("cd /scratch/alpine/testuser/namdrunner_jobs/test_job_001"));
    }

    #[test]
    fn test_generate_namd_config() {
        let job = create_test_job();
        let config = SlurmScriptGenerator::generate_namd_config(&job).unwrap();

        // Verify essential NAMD parameters
        assert!(config.contains("structure          input_files/structure.psf"));
        assert!(config.contains("coordinates        input_files/structure.pdb"));
        assert!(config.contains("outputName         outputs/test_output"));
        assert!(config.contains("set temperature    300"));
        assert!(config.contains("timestep           2"));
        assert!(config.contains("run                100000"));

        // Verify cell basis vectors
        assert!(config.contains("cellBasisVector1   124.0"));
        assert!(config.contains("cellBasisVector2   0.0     114.0"));
        assert!(config.contains("cellBasisVector3   0.0     0.0      323.0"));

        // Verify PME
        assert!(config.contains("PME                yes"));
        assert!(config.contains("PMEGridSpacing     1.5"));

        // Verify NPT
        assert!(config.contains("langevinPiston        on"));
        assert!(config.contains("langevinPistonTarget  1.01325"));

        // Verify extrabonds
        assert!(config.contains("extraBonds         on"));
        assert!(config.contains("extraBondsFile     input_files/restraints.exb"));

        // Verify output frequencies
        assert!(config.contains("xstFreq            1200"));
        assert!(config.contains("outputEnergies     1200"));
        assert!(config.contains("dcdfreq            1200"));
        assert!(config.contains("restartfreq        1200"));
        assert!(config.contains("outputPressure     1200"));
    }

    #[test]
    fn test_minimize_mode() {
        let mut job = create_test_job();
        job.namd_config.execution_mode = ExecutionMode::Minimize;
        job.namd_config.steps = 4800;

        let config = SlurmScriptGenerator::generate_namd_config(&job).unwrap();

        assert!(config.contains("minimize           4800"));
        assert!(!config.contains("run                "));
    }

    #[test]
    fn test_no_pme_no_cell_basis() {
        let mut job = create_test_job();
        job.namd_config.pme_enabled = false;
        job.namd_config.cell_basis_vector1 = None;
        job.namd_config.cell_basis_vector2 = None;
        job.namd_config.cell_basis_vector3 = None;

        let config = SlurmScriptGenerator::generate_namd_config(&job).unwrap();

        assert!(!config.contains("cellBasisVector"));
        assert!(!config.contains("PME                yes"));
        assert!(!config.contains("PMEGridSpacing"));
    }

    #[test]
    fn test_pme_requires_cell_basis() {
        let mut job = create_test_job();
        job.namd_config.pme_enabled = true;
        job.namd_config.cell_basis_vector1 = None;

        let result = SlurmScriptGenerator::generate_namd_config(&job);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("cellBasisVector"));
    }

    #[test]
    fn test_multiple_extrabonds() {
        let mut job = create_test_job();
        job.input_files.push(InputFile {
            name: "dna.enm.extra".to_string(),
            local_path: "/tmp/dna.enm.extra".to_string(),
            remote_name: Some("dna.enm.extra".to_string()),
            file_type: Some(NAMDFileType::Exb),
            size: Some(128),
            uploaded_at: Some(chrono::Utc::now().to_rfc3339()),
        });

        let config = SlurmScriptGenerator::generate_namd_config(&job).unwrap();

        assert!(config.contains("extraBonds         on"));
        assert!(config.contains("extraBondsFile     input_files/restraints.exb"));
        assert!(config.contains("extraBondsFile     input_files/dna.enm.extra"));
    }

    #[test]
    fn test_memory_unit_handling() {
        let mut job = create_test_job();

        // Test bare number gets GB suffix
        job.slurm_config.memory = "64".to_string();
        let script = SlurmScriptGenerator::generate_namd_script(&job).unwrap();
        assert!(script.contains("#SBATCH --mem=64GB"));

        // Test GB is preserved
        job.slurm_config.memory = "32GB".to_string();
        let script = SlurmScriptGenerator::generate_namd_script(&job).unwrap();
        assert!(script.contains("#SBATCH --mem=32GB"));

        // Test MB is preserved
        job.slurm_config.memory = "1024MB".to_string();
        let script = SlurmScriptGenerator::generate_namd_script(&job).unwrap();
        assert!(script.contains("#SBATCH --mem=1024MB"));
    }

    #[test]
    fn test_single_node_validation() {
        let mut job = create_test_job();
        job.slurm_config.cores = 65; // Exceeds single node limit

        let result = SlurmScriptGenerator::generate_namd_script(&job);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("64"));
    }
}